package detector

import (
	"fmt"
	"os/exec"
	"strings"

	"github.com/loop-hub/code-on-rails/internal/config"
)

// Detector identifies AI-generated code
type Detector struct {
	Config *config.DetectionConfig
}

// New creates a new detector
func New(cfg *config.DetectionConfig) *Detector {
	return &Detector{Config: cfg}
}

// DetectFiles finds files that were generated by AI
func (d *Detector) DetectFiles(gitRepo string) ([]string, error) {
	switch d.Config.Method {
	case "commit_message":
		return d.detectByCommitMessage(gitRepo)
	case "git_notes":
		return d.detectByGitNotes(gitRepo)
	case "heuristic":
		return d.detectByHeuristics(gitRepo)
	case "branch":
		return d.detectByBranch(gitRepo)
	case "all":
		// Combine all methods
		files := make(map[string]bool)
		if commitFiles, err := d.detectByCommitMessage(gitRepo); err == nil {
			for _, f := range commitFiles {
				files[f] = true
			}
		}
		if branchFiles, err := d.detectByBranch(gitRepo); err == nil {
			for _, f := range branchFiles {
				files[f] = true
			}
		}
		if noteFiles, err := d.detectByGitNotes(gitRepo); err == nil {
			for _, f := range noteFiles {
				files[f] = true
			}
		}
		if heuristicFiles, err := d.detectByHeuristics(gitRepo); err == nil {
			for _, f := range heuristicFiles {
				files[f] = true
			}
		}
		result := make([]string, 0, len(files))
		for f := range files {
			result = append(result, f)
		}
		return result, nil
	default:
		return d.detectByCommitMessage(gitRepo)
	}
}

// detectByCommitMessage finds files committed with AI tags
func (d *Detector) detectByCommitMessage(gitRepo string) ([]string, error) {
	files := make(map[string]bool)

	// Get recent commits with AI prefixes
	for _, prefix := range d.Config.CommitPrefixes {
		cmd := exec.Command("git", "log", "--all", "--pretty=format:%H", "--grep="+prefix, "-n", "50")
		cmd.Dir = gitRepo
		output, err := cmd.Output()
		if err != nil {
			continue // Skip if git command fails
		}

		commits := strings.Split(strings.TrimSpace(string(output)), "\n")
		for _, commit := range commits {
			if commit == "" {
				continue
			}

			// Get files changed in this commit
			cmdFiles := exec.Command("git", "diff-tree", "--no-commit-id", "--name-only", "-r", commit)
			cmdFiles.Dir = gitRepo
			filesOutput, err := cmdFiles.Output()
			if err != nil {
				continue
			}

			for _, file := range strings.Split(strings.TrimSpace(string(filesOutput)), "\n") {
				if file != "" && strings.HasSuffix(file, ".go") {
					files[file] = true
				}
			}
		}
	}

	result := make([]string, 0, len(files))
	for f := range files {
		result = append(result, f)
	}
	return result, nil
}

// detectByBranch detects AI-generated code by checking if the current branch
// name contains AI tool prefixes (e.g., claude/, ai/, copilot/)
func (d *Detector) detectByBranch(gitRepo string) ([]string, error) {
	// Get current branch name
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = gitRepo
	output, err := cmd.Output()
	if err != nil {
		return []string{}, nil
	}

	branchName := strings.TrimSpace(string(output))

	// Check if branch name starts with any AI prefix
	isAIBranch := false
	for _, prefix := range d.Config.BranchPrefixes {
		if strings.HasPrefix(branchName, prefix) || strings.Contains(branchName, "/"+prefix) {
			isAIBranch = true
			break
		}
	}

	if !isAIBranch {
		return []string{}, nil
	}

	// Find the base branch (main, master, or develop)
	baseBranch := d.findBaseBranch(gitRepo)
	if baseBranch == "" {
		// Fall back to listing all .go files if no base branch found
		return d.getAllGoFiles(gitRepo)
	}

	// Get files changed between base branch and current branch
	return d.getChangedFiles(gitRepo, baseBranch, branchName)
}

// findBaseBranch tries to find the main/master/develop branch
func (d *Detector) findBaseBranch(gitRepo string) string {
	candidates := []string{"main", "master", "develop"}

	for _, branch := range candidates {
		// Check if branch exists locally
		cmd := exec.Command("git", "rev-parse", "--verify", branch)
		cmd.Dir = gitRepo
		if err := cmd.Run(); err == nil {
			return branch
		}

		// Check if branch exists on origin
		cmd = exec.Command("git", "rev-parse", "--verify", "origin/"+branch)
		cmd.Dir = gitRepo
		if err := cmd.Run(); err == nil {
			return "origin/" + branch
		}
	}

	return ""
}

// getChangedFiles returns Go files changed between base and head
func (d *Detector) getChangedFiles(gitRepo, base, head string) ([]string, error) {
	// Find merge base to get accurate diff
	mergeBaseCmd := exec.Command("git", "merge-base", base, head)
	mergeBaseCmd.Dir = gitRepo
	mergeBaseOutput, err := mergeBaseCmd.Output()
	var compareRef string
	if err != nil {
		compareRef = base
	} else {
		compareRef = strings.TrimSpace(string(mergeBaseOutput))
	}

	cmd := exec.Command("git", "diff", "--name-only", compareRef, head)
	cmd.Dir = gitRepo
	output, err := cmd.Output()
	if err != nil {
		return []string{}, nil
	}

	files := []string{}
	for _, file := range strings.Split(strings.TrimSpace(string(output)), "\n") {
		if file != "" && strings.HasSuffix(file, ".go") {
			files = append(files, file)
		}
	}
	return files, nil
}

// getAllGoFiles returns all Go files in the repository
func (d *Detector) getAllGoFiles(gitRepo string) ([]string, error) {
	cmd := exec.Command("git", "ls-files", "*.go", "**/*.go")
	cmd.Dir = gitRepo
	output, err := cmd.Output()
	if err != nil {
		return []string{}, nil
	}

	files := []string{}
	for _, file := range strings.Split(strings.TrimSpace(string(output)), "\n") {
		if file != "" {
			files = append(files, file)
		}
	}
	return files, nil
}

// detectByGitNotes finds files with AI notes
func (d *Detector) detectByGitNotes(gitRepo string) ([]string, error) {
	// This would check git notes for AI markers
	// For PoC, return empty
	return []string{}, nil
}

// detectByHeuristics uses AI code characteristics
func (d *Detector) detectByHeuristics(gitRepo string) ([]string, error) {
	// This would analyze code for AI patterns:
	// - Comprehensive comments
	// - Complete error handling
	// - Consistent formatting
	// - No TODOs
	// For PoC, return empty
	return []string{}, nil
}

// IsAIGenerated checks if a specific file was AI-generated
func (d *Detector) IsAIGenerated(gitRepo, filePath string) (bool, error) {
	files, err := d.DetectFiles(gitRepo)
	if err != nil {
		return false, err
	}

	for _, f := range files {
		if f == filePath {
			return true, nil
		}
	}
	return false, nil
}

// GetAISource tries to determine which AI tool generated the code
func (d *Detector) GetAISource(gitRepo, filePath string) (string, error) {
	// First check commit message
	cmd := exec.Command("git", "log", "-1", "--pretty=format:%s", "--", filePath)
	cmd.Dir = gitRepo
	output, err := cmd.Output()
	if err == nil {
		msg := strings.ToLower(string(output))
		if strings.Contains(msg, "claude") {
			return "claude", nil
		}
		if strings.Contains(msg, "copilot") {
			return "copilot", nil
		}
		if strings.Contains(msg, "cursor") {
			return "cursor", nil
		}
		if strings.Contains(msg, "[ai") {
			return "ai", nil
		}
	}

	// Then check branch name
	branchCmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	branchCmd.Dir = gitRepo
	branchOutput, err := branchCmd.Output()
	if err == nil {
		branch := strings.ToLower(strings.TrimSpace(string(branchOutput)))
		if strings.Contains(branch, "claude") {
			return "claude", nil
		}
		if strings.Contains(branch, "copilot") {
			return "copilot", nil
		}
		if strings.Contains(branch, "cursor") {
			return "cursor", nil
		}
		if strings.HasPrefix(branch, "ai/") || strings.HasPrefix(branch, "ai-") {
			return "ai", nil
		}
	}

	return "unknown", nil
}

// GetRecentAIFiles gets AI files from recent commits
func (d *Detector) GetRecentAIFiles(gitRepo string, days int) ([]string, error) {
	cmd := exec.Command("git", "log", fmt.Sprintf("--since=%d days ago", days), "--name-only", "--pretty=format:")
	cmd.Dir = gitRepo
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	allFiles := strings.Split(strings.TrimSpace(string(output)), "\n")
	aiFiles, err := d.DetectFiles(gitRepo)
	if err != nil {
		return nil, err
	}

	// Filter to only AI files that were recently changed
	aiFileMap := make(map[string]bool)
	for _, f := range aiFiles {
		aiFileMap[f] = true
	}

	result := []string{}
	seen := make(map[string]bool)
	for _, f := range allFiles {
		if f != "" && !seen[f] && aiFileMap[f] {
			result = append(result, f)
			seen[f] = true
		}
	}

	return result, nil
}
