package detector

import (
	"fmt"
	"os/exec"
	"strings"

	"github.com/loop-hub/code-on-rails/internal/config"
)

// Detector identifies AI-generated code
type Detector struct {
	Config *config.DetectionConfig
}

// New creates a new detector
func New(cfg *config.DetectionConfig) *Detector {
	return &Detector{Config: cfg}
}

// DetectFiles finds files that were generated by AI
func (d *Detector) DetectFiles(gitRepo string) ([]string, error) {
	switch d.Config.Method {
	case "commit_message":
		return d.detectByCommitMessage(gitRepo)
	case "git_notes":
		return d.detectByGitNotes(gitRepo)
	case "heuristic":
		return d.detectByHeuristics(gitRepo)
	case "all":
		// Combine all methods
		files := make(map[string]bool)
		if commitFiles, err := d.detectByCommitMessage(gitRepo); err == nil {
			for _, f := range commitFiles {
				files[f] = true
			}
		}
		if noteFiles, err := d.detectByGitNotes(gitRepo); err == nil {
			for _, f := range noteFiles {
				files[f] = true
			}
		}
		if heuristicFiles, err := d.detectByHeuristics(gitRepo); err == nil {
			for _, f := range heuristicFiles {
				files[f] = true
			}
		}
		result := make([]string, 0, len(files))
		for f := range files {
			result = append(result, f)
		}
		return result, nil
	default:
		return d.detectByCommitMessage(gitRepo)
	}
}

// detectByCommitMessage finds files committed with AI tags
func (d *Detector) detectByCommitMessage(gitRepo string) ([]string, error) {
	files := make(map[string]bool)

	// Get recent commits with AI prefixes
	for _, prefix := range d.Config.CommitPrefixes {
		cmd := exec.Command("git", "log", "--all", "--pretty=format:%H", "--grep="+prefix, "-n", "50")
		cmd.Dir = gitRepo
		output, err := cmd.Output()
		if err != nil {
			continue // Skip if git command fails
		}

		commits := strings.Split(strings.TrimSpace(string(output)), "\n")
		for _, commit := range commits {
			if commit == "" {
				continue
			}

			// Get files changed in this commit
			cmdFiles := exec.Command("git", "diff-tree", "--no-commit-id", "--name-only", "-r", commit)
			cmdFiles.Dir = gitRepo
			filesOutput, err := cmdFiles.Output()
			if err != nil {
				continue
			}

			for _, file := range strings.Split(strings.TrimSpace(string(filesOutput)), "\n") {
				if file != "" && strings.HasSuffix(file, ".go") {
					files[file] = true
				}
			}
		}
	}

	result := make([]string, 0, len(files))
	for f := range files {
		result = append(result, f)
	}
	return result, nil
}

// detectByGitNotes finds files with AI notes
func (d *Detector) detectByGitNotes(gitRepo string) ([]string, error) {
	// This would check git notes for AI markers
	// For PoC, return empty
	return []string{}, nil
}

// detectByHeuristics uses AI code characteristics
func (d *Detector) detectByHeuristics(gitRepo string) ([]string, error) {
	// This would analyze code for AI patterns:
	// - Comprehensive comments
	// - Complete error handling
	// - Consistent formatting
	// - No TODOs
	// For PoC, return empty
	return []string{}, nil
}

// IsAIGenerated checks if a specific file was AI-generated
func (d *Detector) IsAIGenerated(gitRepo, filePath string) (bool, error) {
	files, err := d.DetectFiles(gitRepo)
	if err != nil {
		return false, err
	}

	for _, f := range files {
		if f == filePath {
			return true, nil
		}
	}
	return false, nil
}

// GetAISource tries to determine which AI tool generated the code
func (d *Detector) GetAISource(gitRepo, filePath string) (string, error) {
	// Get the commit message for this file
	cmd := exec.Command("git", "log", "-1", "--pretty=format:%s", "--", filePath)
	cmd.Dir = gitRepo
	output, err := cmd.Output()
	if err != nil {
		return "unknown", err
	}

	msg := strings.ToLower(string(output))
	if strings.Contains(msg, "claude") {
		return "claude", nil
	}
	if strings.Contains(msg, "copilot") {
		return "copilot", nil
	}
	if strings.Contains(msg, "cursor") {
		return "cursor", nil
	}
	if strings.Contains(msg, "[ai") {
		return "ai", nil
	}

	return "unknown", nil
}

// GetRecentAIFiles gets AI files from recent commits
func (d *Detector) GetRecentAIFiles(gitRepo string, days int) ([]string, error) {
	cmd := exec.Command("git", "log", fmt.Sprintf("--since=%d days ago", days), "--name-only", "--pretty=format:")
	cmd.Dir = gitRepo
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	allFiles := strings.Split(strings.TrimSpace(string(output)), "\n")
	aiFiles, err := d.DetectFiles(gitRepo)
	if err != nil {
		return nil, err
	}

	// Filter to only AI files that were recently changed
	aiFileMap := make(map[string]bool)
	for _, f := range aiFiles {
		aiFileMap[f] = true
	}

	result := []string{}
	seen := make(map[string]bool)
	for _, f := range allFiles {
		if f != "" && !seen[f] && aiFileMap[f] {
			result = append(result, f)
			seen[f] = true
		}
	}

	return result, nil
}
