name: Code on Rails

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  pattern-check:
    name: Pattern Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Build Code on Rails
        run: go build -o cr ./cmd/cr

      - name: Run pattern check
        id: cr-check
        run: |
          set +e
          OUTPUT=$(./cr check 2>&1)
          EXIT_CODE=$?
          set -e

          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT

          # Save output to file for the comment step
          echo "$OUTPUT" > cr-output.txt

          # Also print to logs
          echo "$OUTPUT"

      - name: Post PR comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const output = fs.readFileSync('cr-output.txt', 'utf8');

            // Parse the output to create a formatted comment
            const lines = output.split('\n');

            let autoApproved = [];
            let needsReview = [];
            let currentFile = null;
            let currentStatus = null;
            let deviations = [];

            for (const line of lines) {
              if (line.startsWith('‚úì') || line.startsWith('‚úî')) {
                currentFile = line.replace(/^[‚úì‚úî]\s*/, '').trim();
                currentStatus = 'approved';
              } else if (line.startsWith('‚ö†') || line.startsWith('!')) {
                currentFile = line.replace(/^[‚ö†!]\s*/, '').trim();
                currentStatus = 'review';
                deviations = [];
              } else if (line.includes('Pattern:') && currentFile) {
                const match = line.match(/Pattern:\s*(.+?)\s*\((\d+)%/);
                if (match) {
                  const [, pattern, score] = match;
                  if (currentStatus === 'approved') {
                    autoApproved.push({ file: currentFile, pattern, score: parseInt(score) });
                  }
                }
              } else if (line.includes('Deviations:')) {
                // Start collecting deviations
              } else if (line.trim().startsWith('-') && currentStatus === 'review') {
                deviations.push(line.trim().substring(1).trim());
              } else if (line.includes('Suggestion:') && currentFile && currentStatus === 'review') {
                needsReview.push({
                  file: currentFile,
                  deviations: [...deviations],
                  suggestion: line.replace(/.*Suggestion:\s*/, '').trim()
                });
                currentFile = null;
                deviations = [];
              }
            }

            // Build the comment
            let comment = '## Code on Rails - Pattern Check Results\n\n';

            if (autoApproved.length > 0) {
              comment += '### ‚úÖ Auto-approved (matches team patterns)\n\n';
              comment += 'These files follow established patterns and need minimal review:\n\n';
              for (const item of autoApproved) {
                comment += `- \`${item.file}\` - ${item.pattern} (${item.score}% match)\n`;
              }
              comment += '\n';
            }

            if (needsReview.length > 0) {
              comment += '### üîç Needs Human Review\n\n';
              comment += 'These files contain novel patterns or business logic that warrant careful review:\n\n';
              for (const item of needsReview) {
                comment += `<details>\n<summary><code>${item.file}</code></summary>\n\n`;
                if (item.deviations.length > 0) {
                  comment += '**Deviations from patterns:**\n';
                  for (const dev of item.deviations) {
                    comment += `- ${dev}\n`;
                  }
                }
                if (item.suggestion) {
                  comment += `\n**Suggestion:** ${item.suggestion}\n`;
                }
                comment += '\n</details>\n\n';
              }
            }

            if (autoApproved.length === 0 && needsReview.length === 0) {
              comment += '### üìã Check Output\n\n';
              comment += '```\n' + output + '\n```\n';
            }

            comment += '\n---\n';
            comment += '_Generated by [Code on Rails](https://github.com/loop-hub/code-on-rails) - Pattern enforcement for AI-generated code_';

            // Find existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' &&
              c.body.includes('Code on Rails - Pattern Check Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
